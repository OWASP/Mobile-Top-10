---

layout: col-sidebar
title: "M3: 不安全的身份驗證/授權"
---

# 威脅主體

**應用層面 特定**

利用身份驗證和授權漏洞的威脅主體通常會通過使用現有或自行創建的工具進行自動化攻擊。

# 攻擊媒介

**利用難度 簡單**

一旦攻擊者瞭解身份驗證或授權架構中的漏洞，他們可以以兩種方式利用這些弱點。他們可能通過直接向手機應用程式的後端伺服器提交服務請求來仿冒或繞過身份驗證，避免與手機應用程式進行直接交互，或者在成功通過身份驗證控制後以合法用戶的身份登錄應用程式，然後強制瀏覽到一個有漏洞的端點以執行管理層級的功能。這兩種利用方法通常是通過裝置中的手機惡意軟體或攻擊者擁有的僵屍網絡完成的。

# 安全性的強度

**普及性 常見**

**偵測性 平均**

為了測試手機應用程式中不良的授權和身份驗證架構，測試人員可以採用多種策略。在授權方面，測試人員可以對手機應用程式進行二進制攻擊，嘗試執行僅在具有較高權限的情況下才能執行的特權功能，特別是在手機應用程式處於「離線」模式時。測試人員還應該嘗試使用相應的 POST/GET 請求，以低權限會話令牌(session token)執行任何特權功能，將這些功能發送到後端伺服器。

不良或有缺失的授權架構可能允許攻擊者以已驗證但較低權限的手機應用程式用戶的身份執行他們不應被授予的功能。當授權決策是在手機裝置內執行而不是通過遠程伺服器進行時，特權升級攻擊的風險會增加，這種情況通常是由於手機要求離線可用性而引起的。

在不良的身份驗證架構方面，測試人員可以在手機應用程式處於「離線」模式時對其進行二進制攻擊，試圖繞過離線身份驗證，然後執行需要離線身份驗證的功能。測試人員還應該嘗試通過從手機應用程式功能的任何 POST/GET 請求中刪除任何會話令牌，以匿名方式執行任何後端伺服器功能。

不良或有缺失的身份驗證架構，會允許攻擊者匿名地在手機應用程式內部，或手機應用程式使用的後端伺服器中執行功能。由於手機裝置的輸入形式，這些在手機應用程式身份驗證中的弱點相當普遍，這種輸入形式通常鼓勵使用短密碼或4位數的PIN碼。

手機應用程式要面對獨特的身份驗證要求，這些要求可能與傳統的網絡身份驗證架構有所不同，主要是因為它們不同的可用性要求。與傳統的網絡應用程式不同，傳統網絡應用程式預期用戶應該在線並實時與後端伺服器進行身份驗證。因為移動網路連線的不穩定性或不可預測性，手機應用程式可能需要滿足不間斷運行的要求，這要求離線身份驗證。這一要求可能會在實施行動裝置身份驗證時，顯著影響開發人員必須考慮的因素。

# 技術性影響

**影響程度 嚴重**

不良的系統授權和身份驗證的技術性影響可能是廣泛的，嚴重的，而且類似的。這在很大程度上取決於超出權限的功能的類型。舉例來說，對於不良的授權，對遠程或本地管理功能的超出權限的程式執行可能會摧毀系統或讓攻擊者能夠訪問敏感信息。

不良身份驗證的所造成的後果，會在解決方案無法識別執行請求的用戶時發生。因為無法建立用戶的身份，這可能會立即導致無法記錄或監聽用戶活動。這種身份驗證的缺失導致難以檢測攻擊的來源，難以了解潛在的漏洞的性質，或制定防止未來攻擊的策略。

此外，身份驗證錯誤還可能暴露底層的授權錯誤。當身份驗證控制失敗時，解決方案無法驗證用戶的身份，而這與用戶的角色和其相關權限密切相關。如果攻擊者可以匿名執行敏感功能，這表明底層程式碼未驗證發出該請求的用戶的權限。因此，程式碼的匿名執行凸顯了身份驗證和授權控制的錯誤。

# 業務影響

**影響程度 嚴重**

不良的身份驗證和授權對業務的影響至少包括以下方面：

* 名聲損害
* 資訊竊盜
* 詐欺
* 未經授權的訪問資料


# 我是否容易受到「不安全的身份驗證/授權」的威脅？

在評估行動裝置應用程式的安全性時，深入理解身份驗證和授權之間的區別至關重要。身份驗證確定個體的身份，而授權驗證已確認的個體是否具有執行特定操作所需的權限。這兩個方面密切相關，因為授權檢查應該立即在身份驗證請求之後執行。

當組織在執行來自行動裝置的請求的 API 之前，在未對個體進行身份驗證的情況下，會發生不安全的授權。因為在沒有建立調用者身份的情況下，幾乎不可能對傳入的請求進行授權檢查。

以下是一些不安全授權的明顯指標：

* **存在越權漏洞 (IDOR)** - IDOR 越權漏洞意味著程式碼未進行適當的授權檢查。
* **隱藏端點** - 開發人員在後端隱藏功能上忽略了授權檢查，他們假設了只有具有適當角色的用戶才能訪問隱藏功能。
* **用戶角色或權限傳輸** - 如果行動應用程式在請求中傳輸用戶的角色或權限到後端系統，這表示存在不安全的授權。

同樣，行動應用程式也會顯示各種不安全身份驗證的跡象：

* **匿名後端 API 的執行** - 具有執行後端 API 服務請求的能力，且無需提供存取令牌的應用程式，意味著不安全的身份驗證。
* **本地儲存密碼或共享密鑰** - 如果應用程式在裝置上本地儲存任何密碼或共享密鑰，這是不安全身份驗證的跡象。
* **弱密碼制度** -  使用簡化的密碼輸入流程可能意味著不安全的身份驗證。
* **使用 FaceID 和 TouchID 等功能** - 使用 FaceID 或 TouchID 等功能可能表示不安全的身份驗證。

# How Do I Prevent 'Insecure Authentication and Authorization'?

To prevent both insecure authentication and authorization, it's crucial to avoid weak patterns and reinforce secure measures.

**Avoid Weak Patterns**

Insecure Mobile Application Authentication Design Patterns should be avoided:

* If you are porting a web application to a mobile equivalent, ensure the authentication requirements of mobile applications match that of the web application component. It should not be possible to authenticate with fewer factors than the web browser.
* Local user authentication can lead to client-side bypass vulnerabilities. If the application stores data locally, the authentication routine can be bypassed on jailbroken devices through runtime manipulation or binary modification. If offline authentication is a compelling business requirement, consult additional guidance on preventing binary attacks against the mobile app.
* Perform all authentication requests server-side, where possible. Upon successful authentication, application data will be loaded onto the mobile device, ensuring application data availability only after successful authentication.
* If client-side data storage is necessary, encrypt the data using an encryption key securely derived from the user’s login credentials. However, there are additional risks that the data will be decrypted via binary attacks.
* The "Remember Me" functionality should never store a user’s password on the device.
* Mobile applications should ideally use a device-specific authentication token that can be revoked within the mobile application by the user, mitigating unauthorized access risks from a stolen/lost device.
* Avoid using spoof-able values for user authentication, including device identifiers or geo-location.
* Persistent authentication within mobile applications should be implemented as an opt-in and not enabled by default.
* Where possible, refrain from allowing users to provide 4-digit PIN numbers for authentication passwords.

**Reinforce Authentication**

* Developers should assume that all client-side authorization and authentication controls can be bypassed by malicious users. Server-side reinforcement of these controls is critical.
* Due to offline usage requirements, mobile apps might need to perform local authentication or authorization checks. In such cases, developers should instrument local integrity checks to detect any unauthorized code changes. Consult additional guidance on detecting and reacting to binary attacks.
* Use FaceID and TouchID to unlock biometrically locked secrets and securely protect sensitive authentication materials, like session tokens.

**Insecure Authorization Prevention**

To avoid insecure authorization:

* Backend systems should independently verify the roles and permissions of the authenticated user. Do not rely on any roles or permission information that comes from the mobile device.
* Assume that all client-side authorization can be bypassed, hence reinforcing server-side authorization controls whenever possible.
* If offline authorization checks are necessary within the mobile app's code, developers should perform local integrity checks to detect unauthorized code changes.

# Example Attack Scenarios

The following scenarios showcase weak authentication or authorization controls in mobile apps:

**Scenario #1:** Hidden Service Requests: Developers assume that only authenticated users will be able to generate a service request that the mobile app submits to its backend for processing. During the processing of the request, the server code does not verify that the incoming request is associated with a known user. Hence, adversaries submit service requests to the back-end service and anonymously execute functionality that affects legitimate users of the solution.

**Scenario #2:** Interface Reliance: Developers assume that only authorized users will be able to see the existence of a particular function on their mobile app. Hence, they expect that only legitimately authorized users will be able to issue the request for the service from their mobile devices. The back-end code that processes the request does not bother to verify that the identity associated with the request is entitled to execute the service. Hence, adversaries are able to perform remote administrative functionality using fairly low-privilege user accounts.

**Scenario #3:** Usability Requirements: Due to usability requirements, mobile apps allow for passwords that are 4 digits long. The server code correctly stores a hashed version of the password. However, due to the severely short length of the password, an adversary will be able to quickly deduce the original passwords using rainbow hash tables. If the password file (or data store) on the server is compromised, an adversary will be able to quickly deduce users' passwords.

**Scenario #4:** Insecure Direct Object Reference: A user makes an API endpoint request to a backend REST API that includes an actor ID and an OAuth bearer token. The user includes their actor ID as part of the incoming URL and includes the access token as a standard header in the request.  The backend verifies the presence of the bearer token but fails to validate the actor ID associated with the bearer token. As a result, the user can tweak the actor ID and attain the account information of other users as part of the REST API request.

**Scenario #5:** Transmission of LDAP roles: A user makes an API endpoint request to a backend REST API that includes a standard oAuth bearer token along with a header that includes a list of LDAP groups that the user belongs to. The backend request validates the bearer token and then inspects the incoming LDAP groups for the right group membership before continuing on to the sensitive functionality. However, the backend system does not perform an independent validation of LDAP group membership and instead relies upon the incoming LDAP information coming from the user. The user can tweak the incoming header and report to be a member of any LDAP group arbitrarily and perform administrative functionality.

# References

- OWASP
    - [OWASP](https://www.owasp.org/index.php/OWASP_Top_Ten)
- External
    - [External References](http://cwe.mitre.org/)
